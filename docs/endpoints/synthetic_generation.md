# Explanation

This endpoint generates batches of queries by sampling one value for each 
attribute per batch. If an attribute is defined as a list, the endpoint will 
exhaustively iterate through all possible combinations of values across such 
lists to generate batches. 

For example, if `max_hops = [2, 3]` and `keep_edge_probability = [0.5, 0.7]`, 
the endpoint will generate 4 batches, corresponding to the combinations 
`(2, 0.5)`, `(2, 0.7)`, `(3, 0.5)`, and `(3, 0.7)`.

This endpoint performs two primary tasks: generating join structures and adding predicates.

The endpoint leverages the foreign key/primary key relationships within the schema to construct various join structures. By traversing the graph representation of these relationships, it explores all possible join configurations.

For predicate generation, the endpoint supports the `IN`, `<`, and `=` operators. It uses statistical information to ensure that each predicate is meaningful and does not result in an empty result set. This guarantees that the generated queries are both valid and useful for testing or benchmarking purposes.

Termination conditions: We ran all possible batches, generating for each batch
up to `max_signatures_per_fact_table` signatures per fact table, and for
each signature up to `max_queries_per_signature` queries.

# Attributes

- `dataset` (str): The dataset to be used (TPCDS, TPCH). This information
is needed to load the correct foreign-key/primary-key information.
- `duckdb_database` (str): The path to the DuckDB database file.
- output_folder (str): The folder to save the generated queries.

- `unique_joins` (bool): Whether to enforce unique joins in the subgraph.
- `max_signatures_per_fact_table` (int): Maximum number of signatures per
signature. This means that for each fact table we will generate this 
number of unique join structures/ signatures.
- `max_queries_per_signature` (int): Maximum number of queries per signature
generated by varying the predicates.

- `max_hops` (list[int]): Maximum number of hops allowed in the subgraph.
- `keep_edge_probability` (float): Probability of retaining an edge in the
subgraph.

- `extra_predicates` (list[int]): Number of column predicates, in addition to 
join predicates to include.
- `row_retention_probability` (list[float]): Probability of retaining a row
for range predicates
- `equality_lower_bound_probability` (float): Lower bound probability when
using the `=` and the `IN` operators
- `extra_values_for_in`: Extra values to add when using the `IN` operator. For
IN we take a value of the most common values and add a number of extra
values to it. This parameter defines how many extra values to add.


## Operator weights

The weights are used to sample the operator for each
predicate. The weights do not need to sum up to 1, they will be
normalized automatically. The higher the weight, the more likely the
operator will be used.
- operator_in : Weight for the `IN` operator.
- operator_equals : Weight for the `=` operator.
- operator_range : Weight for the `<` , `>` operator.

# Output


For each batch processed we store the generated queries under 
`./batch_{batch#}`. We also output the `parameters.toml` which are
the parameters that were used to run generate that set of queries for
reproducibility purposes. 

Finally we also add an `output.parquet` with additional information
of the generated queries.